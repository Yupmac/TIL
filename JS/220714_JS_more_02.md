<aside>
💡 기술 면접에서도 자주 언급되는 사항들이니 충실히 공부해보자.

</aside>

# 함수 표현식, 함수 선언식, 화살표 함수의 차이

### 함수 선언식

- 함수에 이름을 넣어 직접적으로 선언해주는 방식
- 여타의 일반적인 프로그래밍 언어들과 비슷한 방식

### 함수 표현식

- 함수에 특정 이름을 넣지 않은채 변수에 할당하여 사용하는 방식
- 자바스크립트만의 유연한 특징을 반영한 방식
- 클로저로 사용 가능하며, 콜백 함수로도 활용할 수 있다.

<aside>
💡 표현식은 호이스팅의 영향을 받지 않지만, 선언식은 영향을 받는다.
즉, 호출 타이밍이 다르다.

</aside>

### 화살표 함수

- 일반 함수와 다르게 축약형이 가능하다.
- 만약 소괄호 안에 매개 변수가 1개일 경우에는 소괄호 생략 가능.
- 실행문을 반환하는 return 키워드는 {} 안에 있을 경우 작동하나, 추가적인 코드가 없다면 {}, return 키워드를 생략할 수 있다.
- 단, 객체 데이터{}의 경우, 화살표 함수의 블록레벨과 코드가 겹치므로 이 때는 객체 데이터 {} 바깥에 소괄호() 를 추가로 씌워준다.2
- 표현식처럼 따로 함수 이름을 정해줄 수 없고, this, arguments 속성을 사용할 수 없다.
- 단, ES6에서는 (…args) 를 사용해 실제 배열처럼 사용할 수 있다.

> 의문1. 왜 선언식은 호이스팅이 되는데 표현식은 안되는거지? 
의문2(해결). 코딩은 화살표 함수처럼 길이가 줄어들 수록 좋다면서 굳이 다른 방식이 여태껏 남아있는 이유가 뭐지?
→ 화살표 함수는 ES6 부터 적용된 일종의 신기술(?)이다. 당연히 진보되어 있을 수 밖에. 아직 ES5 등의 구형도 남아있을 수 있기 때문에 여전히 다른 방식도 알아야 한다.
> 

# 스코프(Scope)

각 상수나 변수들이 허용된 영역 또는 범위

전역 함수, 전역 변수 등의 개념에서 앞 ‘전역' 부분이 스코프에 해당함.

let, const 는 블록 레벨의 유효범위를 var 는 함수 레벨의 유효범위를 가진다.

예기치 못한 오류 등을 방지하는 차원에서 let, const 사용이 권장된다.

> 근데 우리말로는 범위나 영역이라면서 왜 영어로는 Scope지? 유래를 좀 더 알아볼 필요가 있다. 당장 해봐야겠는데 지금은 당장 못하겠어. 배고파서….. 다음 자습 시간에 알아보자.
> 

let, var, const 의 차이

지역 변수인 let, const 와 다르게 var는 전역 변수이다.

그렇기에 어디에 적더라도 함수 스코프 안에서는 전부 허용된다. 단, 선언 전에 적혔다면 할당 값이 없는 것은 맞기 때문에 undefined로 도출된다.

또한, 익스플로어와 같은 구형 브라우저에서는 var만 적용 가능했었기에 고대 유물이긴 해도 익스플로어 브라우저에 한해 사용되어 왔으나, 이제는 고인이 된 익스플로어이기에 var도 그만 놓아주도록 하자.

# 호이스팅(Hoisting)

- 함수 안에 있는 선언들을 모두 끌어올려서 해당 함수 유효 범위(스코프)의 최상단에 선언하는 것

let, const 의 경우 선언되기 전에 사용하려 하면 ReferenceError(참조 에러)가 발생함.

오로지 var만 선언 이후에도 사용 가능하다.

> 의문1. 서치하다보니 var뿐만 아니라 let, const 또한 호이스팅이 적용된다는 사람도 있던데 누구는 안된다고 하고 누구는 된다고 하고 뭐가 맞는거야? 좀 더 자세히 알아볼 필요가 있겠다. 

의문2. 알아보다 보면 정적, 동적
> 

- 코드의 가독성과 유지보수를 위해 호이스팅이 일어나지 않도록 한다.
호이스팅을 제대로 모르더라도 함수와 변수를 가급적 코드 상단부에서 선언하면, 호이스팅으로 인한 스코프 꼬임 현상은 방지할 수 있다.
let/const를 사용한다.
var를 쓰면 혼란스럽고 쓸모없는 코드가 생길 수 있다. 그럼 왜 var와 호이스팅을 이해해야 할까?
ES6를 어디에서든 쓸 수 있으려면 아직 시간이 더 필요하므로 ES5로 트랜스컴파일을 해야한다.
따라서 아직은 var가 어떻게 동작하는지 이해하고 있어야 한다.
[https://gmlwjd9405.github.io/2019/04/22/javascript-hoisting.html](https://gmlwjd9405.github.io/2019/04/22/javascript-hoisting.html)

# 클로저(Closer)

- 클로저는 함수를 실행하기 전에 해당 함수에 변수를 넘기고 싶을 때 사용된다.

> 아직 제대로 이해되지 않는다. 반드시 추가 공부 필요하다!
> 

# 즉시 실행 함수(IIFE)

- 함수를 만들자 마자 실행시켜 보는 방법
- 익명의 함수는 일반적으로는 실행시킬 수 없으나, IIFE 를 활용해 즉시 실행시켜볼 수 있다.

```jsx
const a = 7

function double() {
	console.log(a * 2)
}
double(); // 아래의 즉시 실행 함수와 겹쳐 오류가 발생하기 때문에 반드시 ; 를 찍어준다.

// 위와 같이 기명 함수일 경우에만 실행 가능했으나,

(function () {
	console.log(a * 2)
}());

// 이렇게 즉시 실행 함수를 이용하여 익명 함수 또한 즉시 실행해볼 수 있다.
```
